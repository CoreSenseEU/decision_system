<?xml version="1.0" encoding="UTF-8"?>
<root BTCPP_format="4">
  <!-- Decide Structure -->
  <BehaviorTree ID="MakeSureGapClosed_Template">
    <Sequence>
      <Fallback>
        <!-- If this gap has already been closed, get the choice from it. -->
        <PrologFetchFromGap gap="{gap}" 
                            query="closed_with('_G', _T)" 
                            target="{choice}" 
                            maxresult="-1"
                            service_name="{@prolog_query}" />
        <Sequence>
          <!-- TODO: implement aborted -->
          <Script code="aborted := false" />
          <Script code="iteration := 0" />

          <!-- TODO: Move these checks to the KB instead -->
          <Script code="choice_last_updated_iteration := -1" />
          <Script code="ordering_last_updated_iteration := -1" />
          <Script code="evaluation_last_updated_iteration := -1" />
          <Script code="assessment_matrix_last_updated_iteration := -1" />
          <Script code="choice_set_last_updated_iteration := -1" />
          <Script code="cues_last_updated_iteration := -1" />

          <!-- TODO: adjust make num_attempts a parameter -->
          <RetryUntilSuccessful _while="!aborted" num_attempts="10">
            <!-- Make sure done -->
            <Sequence> 
              <SubTree ID="MakeSureChoiceTaken_Template" _autoremap="true" />
              <SubTree ID="MakeSureChoiceAccepted_Template" _autoremap="true" />
              <Script code="iteration += 1" />
            </Sequence>
          </RetryUntilSuccessful>
          <AlwaysSuccess _failureIf="aborted | !accepted"/>
        </Sequence>
      </Fallback>

      <!-- TODO: this creates duplicate entires in the database if the gap was already closed. -->
      <CloseGap gap="{gap}"
                choice="{choice}" 
                topic_name="{@prolog_assert}" />
    </Sequence>
  </BehaviorTree>
</root>
