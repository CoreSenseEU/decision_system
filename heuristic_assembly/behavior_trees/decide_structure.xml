<?xml version="1.0" encoding="UTF-8"?>
<root BTCPP_format="4">
  <!-- Decide Structure -->
  <BehaviorTree ID="MakeSureGapClosed">
    <Sequence>
      <Fallback>
        <!-- If this gap has already been closed, get the choice from it. -->
        <PrologFetchFromGap gap="{gap}" 
                            query="closed_with('_G', _T)" 
                            target="{choice}" 
                            maxresult="-1"
                            service_name="{@prolog_query}" />
        <Sequence>
          <!-- TODO: implement aborted -->
          <Script code="aborted := false" />
          <!-- TODO: adjust make num_attempts a parameter -->
          <RetryUntilSuccessful _while="!aborted" num_attempts="10">
            <!-- Make sure done -->
            <Sequence> 

            <!-- TODO: this is implied by MakeSureChoiceAccepted, and doing it twice changes the
              assumptions of MakeSureAlternativesUpdated/MakeSureCuesUpdated
            Removing it here breaks the pattern, and really checks should be added for each iteration. -->

              <!-- <SubTree ID="MakeSureChoiceTaken" _autoremap="true" /> -->
              <SubTree ID="MakeSureChoiceAccepted" _autoremap="true" />
            </Sequence>
          </RetryUntilSuccessful>
          <AlwaysSuccess _failureIf="aborted | !accepted"/>
        </Sequence>
      </Fallback>

      <!-- TODO: this creates duplicate entires in the database if the gap was already closed. -->
      <CloseGap gap="{gap}"
                choice="{choice}" 
                topic_name="{@prolog_assert}" />
    </Sequence>
  </BehaviorTree>
</root>
